let name;         //declared using let
name = "Sam";     //assigned value
name = "David";   //reassigned (allowed with let)

let age = 25;     //declared and initialized

var city = "Chennai";  //declared and initialized with var
var city = "Delhi";    //redeclared using var (allowed with var)



slice , splice
find , filter




closure ==> inner function can still use outer function's variable even after outer is finished
ex:  
  function outer(){
        let  name = "SAM"

          function inner(){
            console.log(name)
            }
          return inner;
  }
  const greets = outer();
  greets()
==>output=>SAM


function outer() {
    let name = "SAM";

    function inner() {
        console.log(name);
    }

    inner();  // directly called here
}

outer(); // prints "SAM"






Portion (does NOT change original array → new copy create pannum)

  slice(start, end) → portion of array return pannum.
  map() → new array create pannum.
  filter() → condition kooda new array return pannum.
  find() → condition satisfy panna first element return pannum (original unchanged).
  concat() → 2 arrays join pannum → new array return.
  toString() / join() → string return pannum (array untouched).

Original (changes the actual array → mutate pannum)

  push() → add to end.
  pop() → remove last.
  shift() → remove first.
  unshift() → add to start.
  splice(start, deleteCount, items...) → delete/insert original la change.
  sort() → array la order change pannum.
  reverse() → order reverse pannum.

ex:
Original Array:

copyWithin
fill
pop
push
reverse
shift
sort
splice
unshift


Do NOT Modify Original Array:

at
concat
entries
every
filter
find
findIndex
findLast
findLastIndex
flat
flatMap
forEach
includes
indexOf
join
keys
lastIndexOf
map
reduce
reduceRight
slice
some
toLocaleString
toString
values
toReversed
toSorted
toSpliced
with

Static (Array Class Itself):

Array.isArray
Array.from
Array.of


